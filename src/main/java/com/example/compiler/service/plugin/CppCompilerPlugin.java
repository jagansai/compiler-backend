package com.example.compiler.service.plugin;

import com.example.compiler.config.CompilerConfig;
import com.example.compiler.model.CompilationRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * Plugin for C++ compilation and assembly generation.
 * Supports g++ and MSVC (cl.exe) compilers.
 */
@Component
public class CppCompilerPlugin implements CompilerPlugin {
    
    private static final Logger log = LoggerFactory.getLogger(CppCompilerPlugin.class);
    private static final String LANGUAGE = "cpp";
    private static final String GXX = "g++";
    private static final String CL = "cl";
    
    private final CompilerConfig config;
    
    public CppCompilerPlugin(CompilerConfig config) {
        this.config = config;
    }
    
    @Override
    public String getLanguage() {
        return LANGUAGE;
    }
    
    @Override
    public String[] getSupportedCompilers() {
        return new String[] { GXX, CL };
    }
    
    @Override
    public String[] getDefaultCompilerOptions() {
        return new String[] { "-O0", "-O1", "-O2", "-O3" };
    }
    
    @Override
    public CompilationResult compile(CompilationRequest request, Path sourceFile, int timeout) throws Exception {
        String compiler = determineCompiler(request);
        ProcessBuilder pb = createCompileProcess(sourceFile, compiler, request.getCompilerOptions());
        
        Process process = pb.start();
        boolean completed = process.waitFor(timeout, TimeUnit.SECONDS);
        
        if (!completed) {
            process.destroyForcibly();
            throw new RuntimeException("C++ compilation timed out");
        }
        
        if (process.exitValue() != 0) {
            StringBuilder errorOutput = new StringBuilder();
            try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                String line;
                while ((line = errorReader.readLine()) != null) {
                    errorOutput.append(line).append("\n");
                }
            }
            return CompilationResult.failure(errorOutput.toString());
        }
        
        log.debug("C++ compilation succeeded with {}: {}", compiler, sourceFile);
        return CompilationResult.success();
    }
    
    @Override
    public String generateAssembly(CompilationRequest request, Path sourceFile, int timeout) throws Exception {
        String compiler = determineCompiler(request);
        ProcessBuilder pb = createAsmProcess(sourceFile, compiler, request.getCompilerOptions());
        
        Process process = pb.start();
        boolean completed = process.waitFor(timeout, TimeUnit.SECONDS);
        
        if (!completed) {
            process.destroyForcibly();
            throw new RuntimeException("Assembly generation timed out");
        }
        
        StringBuilder output = new StringBuilder();
        
        if (CL.equals(compiler)) {
            // For MSVC, read the generated .asm file
            Path asmFile = Path.of(sourceFile.toString() + ".asm");
            if (Files.exists(asmFile)) {
                log.debug("Reading MSVC assembly output from: {}", asmFile);
                output.append(Files.readString(asmFile));
                // Clean up asm file
                Files.deleteIfExists(asmFile);
            } else {
                throw new RuntimeException("Assembly file not generated by MSVC");
            }
        } else {
            // For G++, read from process output
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }
            }
        }
        
        if (process.exitValue() != 0) {
            log.error("Assembly generation failed with exit code: {}", process.exitValue());
            throw new RuntimeException("Failed to generate assembly output");
        }
        
        String assemblyOutput = output.toString();
        
        // Sanitize MSVC output if using cl compiler
        if (CL.equals(compiler)) {
            assemblyOutput = sanitizeMSVCAssembly(assemblyOutput);
        }
        
        return assemblyOutput;
    }
    
    @Override
    public String execute(CompilationRequest request, Path sourceFile, int timeout) throws Exception {
        // First compile to executable
        String compiler = determineCompiler(request);
        Path exeFile = Path.of(sourceFile.toString().replace(".cpp", ".exe"));
        
        ProcessBuilder compilePb = createExecutableCompileProcess(sourceFile, compiler, request.getCompilerOptions(), exeFile);
        Process compileProcess = compilePb.start();
        
        boolean compileCompleted = compileProcess.waitFor(timeout, TimeUnit.SECONDS);
        if (!compileCompleted) {
            compileProcess.destroyForcibly();
            throw new RuntimeException("C++ executable compilation timed out");
        }
        
        if (compileProcess.exitValue() != 0) {
            StringBuilder errorOutput = new StringBuilder();
            try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(compileProcess.getErrorStream()))) {
                String line;
                while ((line = errorReader.readLine()) != null) {
                    errorOutput.append(line).append("\n");
                }
            }
            throw new RuntimeException("C++ compilation failed: " + errorOutput.toString());
        }
        
        // Execute the compiled program
        ProcessBuilder pb = new ProcessBuilder(exeFile.toString())
                .redirectErrorStream(true);
        
        Process process = pb.start();
        
        // Read output while process is running
        StringBuilder output = new StringBuilder();
        Thread outputReader = new Thread(() -> {
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }
            } catch (Exception e) {
                log.warn("Error reading C++ execution output", e);
            }
        });
        outputReader.start();
        
        boolean completed = process.waitFor(timeout, TimeUnit.SECONDS);
        outputReader.join(1000);
        
        if (!completed) {
            process.destroyForcibly();
            throw new RuntimeException("C++ execution timed out");
        }
        
        if (process.exitValue() != 0) {
            log.warn("C++ execution returned non-zero exit code: {}", process.exitValue());
        }
        
        return output.toString();
    }
    
    private ProcessBuilder createExecutableCompileProcess(Path sourceFile, String compiler, String options, Path outFile) {
        if (CL.equals(compiler)) {
            return new ProcessBuilder(compiler, "/nologo", "/EHsc", "/Fe" + outFile, sourceFile.toString())
                    .directory(sourceFile.getParent().toFile());
        } else {
            return new ProcessBuilder(compiler, sourceFile.toString(), "-o", outFile.toString())
                    .directory(sourceFile.getParent().toFile());
        }
    }
    
    @Override
    public Path createSourceFile(String code, Path workDirectory) throws Exception {
        String fileName = UUID.randomUUID().toString();
        Path filePath = workDirectory.resolve(fileName + ".cpp");
        Files.writeString(filePath, code);
        log.debug("Created C++ source file: {}", filePath);
        return filePath;
    }
    
    @Override
    public void cleanup(Path sourceFile) {
        try {
            if (sourceFile != null && Files.exists(sourceFile)) {
                Files.deleteIfExists(sourceFile);
                // Delete executable
                Files.deleteIfExists(Path.of(sourceFile.toString() + ".exe"));
                // Delete MSVC intermediate files
                Files.deleteIfExists(Path.of(sourceFile.toString() + ".obj"));
                Files.deleteIfExists(Path.of(sourceFile.toString() + ".asm"));
                log.debug("Cleaned up C++ files: {}", sourceFile);
            }
        } catch (Exception e) {
            log.warn("Error cleaning up C++ files", e);
        }
    }
    
    private String determineCompiler(CompilationRequest request) {
        // Use compilerId to determine compiler
        // For now, map compilerId to compiler command
        // In future, this should use the config service to get actual paths
        String compilerId = request.getCompilerId();
        
        if (compilerId != null) {
            if (compilerId.equals("msvc") || compilerId.contains("cl")) {
                return CL;
            } else if (compilerId.equals("gcc") || compilerId.contains("g++") || compilerId.contains("gcc")) {
                return GXX;
            }
        }
        
        // Use preferred compiler from config if set
        String preferredCompiler = config.getCpp().getPreferredCompiler();
        if (preferredCompiler != null && !preferredCompiler.isEmpty()) {
            if (GXX.equals(preferredCompiler) && isGppAvailable()) {
                log.info("Using preferred compiler: g++");
                return GXX;
            } else if (CL.equals(preferredCompiler) && isMsvcAvailable()) {
                log.info("Using preferred compiler: cl (MSVC)");
                return CL;
            }
            log.warn("Preferred compiler {} not available, auto-detecting", preferredCompiler);
        }
        
        // Auto-detect available compiler
        return detectAvailableCompiler();
    }
    
    private String detectAvailableCompiler() {
        // Try MSVC first if we're on Windows
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            if (isMsvcAvailable()) {
                log.info("Using MSVC compiler");
                return CL;
            }
        }
        
        // Try G++
        if (isGppAvailable()) {
            log.info("Using G++ compiler");
            return GXX;
        }
        
        log.error("No C++ compiler found. Current PATH: {}", System.getenv("PATH"));
        throw new IllegalStateException(
                "No C++ compiler found. Please install either G++ or MSVC.");
    }
    
    private boolean isMsvcAvailable() {
        // Check custom configured paths first
        for (String path : config.getCpp().getMsvcPaths()) {
            if (path != null && !path.isEmpty() && new File(path).exists()) {
                log.info("Found MSVC at configured path: {}", path);
                return true;
            }
        }
        
        // Try using vswhere to locate it
        String vswherePath = config.getCpp().getVswherePath();
        if (vswherePath != null && new File(vswherePath).exists()) {
            try {
                Process vsWhere = new ProcessBuilder(
                        vswherePath,
                        "-latest",
                        "-products", "*",
                        "-requires", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
                        "-property", "installationPath").start();
                
                BufferedReader reader = new BufferedReader(new InputStreamReader(vsWhere.getInputStream()));
                String vsPath = reader.readLine();
                
                if (vsPath != null && !vsPath.isEmpty()) {
                    log.info("Found Visual Studio installation at: {}", vsPath);
                    return true;
                }
            } catch (Exception e) {
                log.debug("VSWhere detection failed", e);
            }
        }
        
        // Try cl.exe in PATH
        try {
            Process clProcess = new ProcessBuilder("cl").start();
            if (clProcess.waitFor(5, TimeUnit.SECONDS)) {
                return true;
            }
        } catch (Exception e) {
            log.debug("Failed to find cl.exe in PATH", e);
        }
        
        return false;
    }
    
    private boolean isGppAvailable() {
        try {
            Process gppProcess = new ProcessBuilder("g++", "--version").start();
            return gppProcess.waitFor(5, TimeUnit.SECONDS) && gppProcess.exitValue() == 0;
        } catch (Exception e) {
            log.debug("G++ not found or not working", e);
            return false;
        }
    }
    
    private ProcessBuilder createCompileProcess(Path sourceFile, String compiler, String compilerOptions) {
        ProcessBuilder pb;
        String sourceFileStr = sourceFile.toString();
        
        switch (compiler) {
            case GXX:
                pb = new ProcessBuilder(GXX, sourceFileStr, "-o", sourceFileStr + ".exe");
                if (compilerOptions != null && !compilerOptions.isEmpty()) {
                    for (String opt : compilerOptions.trim().split("\\s+")) {
                        pb.command().add(opt);
                    }
                }
                break;
                
            case CL:
                pb = new ProcessBuilder(
                        "cmd", "/c",
                        CL, "/nologo", "/EHsc", sourceFileStr,
                        "/Fe:" + sourceFileStr + ".exe");
                if (compilerOptions != null && !compilerOptions.isEmpty()) {
                    for (String opt : compilerOptions.trim().split("\\s+")) {
                        pb.command().add(opt);
                    }
                }
                setupMSVCEnvironment(pb);
                break;
                
            default:
                throw new IllegalArgumentException("Unsupported C++ compiler: " + compiler);
        }
        
        return pb;
    }
    
    private ProcessBuilder createAsmProcess(Path sourceFile, String compiler, String compilerOptions) {
        String sourceFileStr = sourceFile.toString();
        ProcessBuilder pb;
        
        switch (compiler) {
            case GXX:
                pb = new ProcessBuilder(GXX, "-S", "-o", "-", sourceFileStr);
                if (compilerOptions != null && !compilerOptions.isEmpty()) {
                    for (String opt : compilerOptions.trim().split("\\s+")) {
                        pb.command().add(pb.command().size() - 1, opt); // Insert before sourceFileStr
                    }
                }
                return pb;
                
            case CL:
                pb = new ProcessBuilder(
                        "cmd", "/c",
                        CL, "/nologo", "/c", "/FAs",
                        "/Fa" + sourceFileStr + ".asm",
                        sourceFileStr);
                if (compilerOptions != null && !compilerOptions.isEmpty()) {
                    for (String opt : compilerOptions.trim().split("\\s+")) {
                        pb.command().add(pb.command().size() - 1, opt); // Insert before sourceFileStr
                    }
                }
                setupMSVCEnvironment(pb);
                return pb;
                
            default:
                throw new IllegalStateException("Unsupported compiler: " + compiler);
        }
    }
    
    private void setupMSVCEnvironment(ProcessBuilder pb) {
        try {
            // Use explicitly configured vcvars path if available
            String vcvarsPath = config.getCpp().getVcvarsPath();
            if (vcvarsPath != null && !vcvarsPath.isEmpty() && new File(vcvarsPath).exists()) {
                setupVCVarsEnvironment(pb, vcvarsPath);
                return;
            }
            
            // Try to find vcvars from configured MSVC paths
            for (String msvcPath : config.getCpp().getMsvcPaths()) {
                if (msvcPath != null && !msvcPath.isEmpty() && new File(msvcPath).exists()) {
                    // Navigate up from cl.exe path to find vcvars64.bat
                    File clFile = new File(msvcPath);
                    File vcToolsRoot = clFile.getParentFile().getParentFile().getParentFile().getParentFile().getParentFile();
                    File vcvarsFile = new File(vcToolsRoot, "Auxiliary\\Build\\vcvars64.bat");
                    
                    if (vcvarsFile.exists()) {
                        setupVCVarsEnvironment(pb, vcvarsFile.getAbsolutePath());
                        return;
                    }
                }
            }
            
            // Fallback to vswhere
            String vswherePath = config.getCpp().getVswherePath();
            if (vswherePath != null && new File(vswherePath).exists()) {
                Process vsWhere = new ProcessBuilder(
                        vswherePath,
                        "-latest",
                        "-products", "*",
                        "-requires", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
                        "-property", "installationPath").start();
                
                BufferedReader reader = new BufferedReader(new InputStreamReader(vsWhere.getInputStream()));
                String vsPath = reader.readLine();
                
                if (vsPath != null && !vsPath.isEmpty()) {
                    String vcvars = vsPath + "\\VC\\Auxiliary\\Build\\vcvars64.bat";
                    setupVCVarsEnvironment(pb, vcvars);
                    return;
                }
            }
            
            log.warn("Could not find Visual Studio installation");
            pb.environment().put("PATH", System.getenv("PATH"));
        } catch (Exception e) {
            log.error("Error setting up MSVC environment", e);
            throw new RuntimeException("Failed to set up MSVC environment: " + e.getMessage(), e);
        }
    }
    
    private void setupVCVarsEnvironment(ProcessBuilder pb, String vcvarsPath) throws Exception {
        log.debug("Setting up MSVC environment using vcvars64.bat at: {}", vcvarsPath);
        
        // Create a temporary batch file to capture environment variables
        Path tempBat = Files.createTempFile("vcvars", ".bat");
        Files.writeString(tempBat,
                "@echo off\n" +
                        "call \"" + vcvarsPath + "\"\n" +
                        "set\n");
        
        // Run the batch file and capture environment variables
        Process envProcess = new ProcessBuilder("cmd", "/c", tempBat.toString())
                .redirectErrorStream(true)
                .start();
        
        Map<String, String> env = pb.environment();
        BufferedReader reader = new BufferedReader(new InputStreamReader(envProcess.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.contains("=")) {
                String[] parts = line.split("=", 2);
                env.put(parts[0], parts[1]);
            }
        }
        
        boolean completed = envProcess.waitFor(10, TimeUnit.SECONDS);
        if (!completed || envProcess.exitValue() != 0) {
            log.error("Failed to set up MSVC environment using vcvars64.bat");
            throw new RuntimeException("Failed to set up MSVC environment");
        }
        
        // Cleanup
        Files.delete(tempBat);
        log.debug("Successfully set up MSVC environment");
    }
    
    /**
     * Sanitize MSVC assembly output by removing unnecessary metadata and noise.
     * This makes the assembly output more readable by filtering out:
     * - include directives
     * - INCLUDELIB directives
     * - Temp file paths in comments
     * - Empty lines at the start
     */
    private String sanitizeMSVCAssembly(String assembly) {
        if (assembly == null || assembly.isEmpty()) {
            return assembly;
        }
        
        StringBuilder sanitized = new StringBuilder();
        String[] lines = assembly.split("\n");
        boolean inCodeSection = false;
        
        for (String line : lines) {
            String trimmed = line.trim();
            
            // Skip include directives
            if (trimmed.startsWith("include ") || trimmed.startsWith("INCLUDE ")) {
                continue;
            }
            
            // Skip INCLUDELIB directives
            if (trimmed.startsWith("INCLUDELIB ")) {
                continue;
            }
            
            // Skip listing generation comment
            if (trimmed.startsWith("; Listing generated by")) {
                continue;
            }
            
            // Sanitize file path comments (remove temp directory paths)
            if (trimmed.startsWith("; File ")) {
                // Extract just the filename without the full temp path
                int lastSlash = Math.max(trimmed.lastIndexOf('\\'), trimmed.lastIndexOf('/'));
                if (lastSlash > 0 && lastSlash < trimmed.length() - 1) {
                    String filename = trimmed.substring(lastSlash + 1);
                    sanitized.append("; File ").append(filename).append("\n");
                } else {
                    sanitized.append(line).append("\n");
                }
                continue;
            }
            
            // Skip empty lines at the start, but keep them once we're in code
            if (!inCodeSection && trimmed.isEmpty()) {
                continue;
            }
            
            if (!trimmed.isEmpty()) {
                inCodeSection = true;
            }
            
            sanitized.append(line).append("\n");
        }
        
        return sanitized.toString();
    }
}
